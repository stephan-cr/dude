#!/usr/bin/env python
#    -*- mode: python -*-

# Copyright (c) 2010 Diogo Becker
# Distributed under the MIT License
# See accompanying file LICENSE

"""dude - framework for experiments"""

import os
import sys
import optparse
import imp

import dude

if __name__ == '__main__':
     desc = """Commands:
       clean\t delete experiments
       failed\t list all failed experiments
       info\t show experiment description info
       list\t list directories of executed experiments
       missing\t list all missing experiments
       run\t run all experiments
       sum\t summarize results using given summaries
     """
     parser = optparse.OptionParser(usage="%prog [options] command",
                                    version="%prog " + dude.__version__,
                                    description = desc,
                                    formatter = dude.utils.IndentedHelpFormatterWithNL())
     parser.add_option("-f", "--file", dest = "expfile",
                       help="read FILE as a Dudefile", metavar = "FILE")
     parser.add_option("-x", "--filter", "--select",
                       dest = "filter", metavar = "FILTERS",
                       help = "select experiments using filters written in Dudefile\ne.g. -x filter1,filter2")
     parser.add_option("-y", "--filter-inline",
                       dest = "filter_inline", metavar = "FILTERS",
                       help = "select experiments using inline filters separated by semicolons"
                       "\ne.g. -y \"option1=value;option2=[value3,value4]\"")
     parser.add_option("-i",  "--invert-filters", default = False,
                       dest = "invert", action = "store_true",
                       help = "invert filter selection")
     parser.add_option("-a", "--args",
                       dest = "margs", metavar = "ARGS",
                       help = "arguments to Dudefile separated by semicolons"
                       "\ne.g. -a \"option1=value;option2=[value3,value4]\"")
     parser.add_option("--dry", default = False,
                       dest = "dry", action = "store_true",
                       help = "dry run (sets global dry variable to True)")
     group2 = optparse.OptionGroup(parser, 'run specific options')
     group2.add_option("-n","--no-output", action = "store_false",
                       dest = "show_output", default = True,
                       help = "omit the output of experiment")
     group2.add_option("--force", action = "store_true",
                       dest = "force", default = False,
                       help = "force execution")
     group2.add_option("--skip-global", default = False,
                       dest = "skip_global", action = "store_true",
                       help = "skip global prepare")
     group2.add_option("--global-only", default = False,
                       dest = "global_only", action = "store_true",
                       help = "run global prepare only")

     group3 = optparse.OptionGroup(parser, 'sum specific options')
     group3.add_option('-b', '--backend', dest = 'backend', default = 'file',
                       help = 'backend to use for summary',
                       choices = dude.summary_backends.backend_names())

     group4 = optparse.OptionGroup(parser, 'list specific options')
     group4.add_option("-d", "--dict", action = "store_true",
                       dest = "dict", default = False,
                       help = "show output in dict format")

     parser.add_option_group(group2)
     parser.add_option_group(group3)
     parser.add_option_group(group4)


     (options, args) = parser.parse_args()


     # check if file exists
     if args != []:
          if args[0] == "create":
               dude.expgen.create(args[1])
               sys.exit(0)

          e = None
          if not options.expfile == None:
               try:
                    e = imp.load_source('', options.expfile)
                    e.root = os.getcwd()
               except IOError:
                    print >> sys.stderr, 'ERROR: Loading', options.expfile, 'failed'
                    parser.print_help()
                    sys.exit(1)
          else:
               for f in ['desc.py', 'dudefile', 'Dudefile', 'dudefile.py']:
                    try:
                         e = imp.load_source('', f)
                         e.root = os.getcwd()
                         break
                    except IOError:
                         pass
               if e == None:
                    print >> sys.stderr, 'ERROR: no dudefile found'
                    parser.print_help()
                    sys.exit(1)

          dude.core.check_cfg(e)
          dude.summary.check_cfg(e)

          # set dry run variable
          if options.dry:
               e.dry = True
          else:
               e.dry = False

          # parse arguments to module
          if options.margs:
               margs = dude.args.parse(options.margs)
               print "arguments to Dudefile:", margs
               dude.args.set_args(e, margs)

          if hasattr(e, 'dude_version') and e.dude_version >= 3:
               dude.dimensions.update(e)

          # TODO: the selection of experiments and how that interact with the commands should be redone.
          # the last parameter to filter_experiments include or exclude the not yet run experiments

          experiments = []
          if options.filter != None:
               filters = []
               for f in options.filter.split(','):
                    filters.append(e.filters[f])
               experiments = dude.filter.filter_experiments(e, filters, options.invert, True)
          elif options.filter_inline:
               experiments = dude.filter.filter_inline(e, options.filter_inline, options.invert, False)
          else:
               experiments = dude.core.get_run_experiments(e)

          cmd = args[0]
          if cmd == 'run':
               dude.execute.init()
               if options.force:
                    dude.clean.clean_experiments(e, experiments)
               dude.execute.run(e, experiments, options)
          elif cmd == 'run-once':
               assert len(experiments) == 1
               optpt =  experiments[0][1]
               dude.execute.init()
               folder = "once"
               dude.utils.checkFolder(folder) # create if necessary
               if options.force:
                    dude.clean.clean_experiment(folder)
               dude.execute.execute(e, optpt, 1, options.show_output, folder)
          elif cmd == 'sum':
               dude.summary.summarize(e, experiments, args[1:], options.backend)
          elif cmd == 'list':
               for run, experiment in experiments:
                    if options.dict:
                         print "run:",run, "experiment:", experiment
                    else:
                         print dude.core.get_folder(e, experiment, run)
          elif cmd == 'failed':
               failed = dude.core.get_failed(e, False)
               for ffile in failed:
                    print ffile
          elif cmd == 'missing':
               failed = dude.core.get_failed(e, True)
               for exp in failed:
                    print exp
          elif cmd == 'force-fail':
               print "ERROR: Command not implemented!"
               sys.exit(1)
          elif cmd == 'clean':
               # TODO if no filter applied, ask if that's really what the user wants.
               r = 'y'
               if options.filter == None and options.filter_inline == None:
                    print "sure to wanna delete everything? [y/N]"
                    r = dude.utils.getch() #raw_input("Skip, quit, or continue? [s/q/c]")

               if r == 'y':
                    dude.clean.clean_experiments(e, experiments)
          elif cmd == 'info':
               dude.info.show_info(e)
          else:
               print >> sys.stderr, "ERROR: wrong command."
               parser.print_help()

     else:
          parser.print_help()
          sys.exit()
